\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{listings}
\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

% \lstset{
%  columns=fixed,       
%  numbers=left,                                        % 在左侧显示行号
%  numberstyle=\small\color{gray},                       % 设定行号格式
%  frame=none,                                          % 不显示背景边框
%  backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
%  keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
%  numberstyle=\footnotesize\color{darkgray},           
%  commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
%  stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
%  showstringspaces=false,                              % 不显示字符串中的空格
%  language=c++,                                        % 设置语言
% }

% \usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                       % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for a
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Problem \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Homework\ \#2}
\newcommand{\hmwkDueDate}{Jan. 31, 2019}
\newcommand{\hmwkClass}{CPSC8400}
\newcommand{\hmwkClassTime}{}
\newcommand{\hmwkClassInstructor}{Professor Dr.Brian Dean}
\newcommand{\hmwkAuthorName}{\textbf{Guoze Tang}}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate\ at 12:25pm}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem}
\textbf{2-1. Property Testing.} Please do problem 15 (chapter 2). As a hint, the bounds on $(1 + x)^y$ on page 47 may end up being useful.

\textbf{Analyze}

This algorithm always gives us the correct output if the input array is sorted. So, we only need to think about the second situation (The array is "far" from sorted.): The input array is unsorted, but we give an incorrect answer. We only make the mistake when we choose a consistent element on each of the longest increasing sub-sequence, then we will get the incorrect output. And the algorithm runs binary searches to test consistency of $O(\frac{1}{\varepsilon}\log n)$, and its total running time is $O(\frac{1}{\varepsilon}\log^2n)$.  There are some conditions in this problem. 

\textbf{Conditions}

\begin{enumerate}
    \item The longest increasing sub-sequence length $< (1-\varepsilon)n$
    \item The probability of randomly choosing one of the increasing sub-sequence is $ 1 - \varepsilon$
    \item If we make the mistake when we choose a consistent element is $O(\frac{1}{\varepsilon}\log n)$
\end{enumerate}
Base on these definitions,  we use $P(failure)$ as the probability of making a mistake. Then we can get the followed formula
\[
    \begin{split}
        P(failure) &\leq (1-\varepsilon)^{k}
    \end{split}
\]

From the page 47 of the textbook draft, we can use the result about $(1 + x)^y \leq e^{xy} $ to deal with the above result. We can change this formula to $(1 - x)^y \leq e^{-xy}$. And, we define the $k = \frac{m}{\varepsilon}\ln (n)$. Then use these definitions, we can get the followed formula.
\[
    \begin{split}
        P(failure) &\leq (1-\varepsilon)^{\frac{m}{\varepsilon}\ln (n)}
        \\
        &\leq e^{-\varepsilon * \frac{m}{\varepsilon}\ln (n)}
        \\
        &= e^{-m ln (n)} \\
        &= \frac{1}{n^m}
    \end{split}
\]

Now, we can change the $m$ to make the $ P(failure)$ is very low. As a result, we can get a high probability of success.


 
\end{homeworkProblem}

\pagebreak

\pagebreak

\begin{homeworkProblem}
% \textbf{2-2. A Priority Queue Built from Sorted Arrays}. Please do problem 93 (chapter 5)

\textbf{Requirements}
    \begin{enumerate}
        \item Prove both $insert$ and $remove$-$min$ run in only $O(\log n)$ amortized time.
        \item Is it possible to implement the remaining priority queue operations $decrease$-$key$, $increase$-$key$, and $delete$ in $O(\log n)$ amortized time?
    \end{enumerate}


\textbf{Definition}
    \begin{enumerate}
        \item Array $A_1$ and $A_2$ are two arrays in all the arrays which need to merge.
        \item $length(A_1)$ is the length for $A_1$ and $length(A_2)$ is the length for $A_2$. $length(A_1)\leq length(A_2)$, but $2*length(A_1) \geq length(A_2)$;
        \item $C_i$ is the number of the arrays which are longer than the array which contain the this element i. 
        \item The number of all the arrays $\leq \log_2n$, n is the number of elements in this structure.
    \end{enumerate}

\textbf{Accounting Method:} When we want to insert a new element $i$, each inserts operation create a single array, this costs us \$1. In addition, we have to store another \$$3C_i \leq 3\log_2 n = \log n * \log_2n = O(\log n)$ in the bank. This saving will be used for merging arrays for this element in the future. For example, when we merge two arrays $A_1$ and $A_2$ and $length(A_1)\leq length(A_2)$. For each elements in the $A_1$, we need to pay with the \$3 associated with each element in the array $A_1$. So this merge cost is \$$3* length(A_1)$. We use this cost to pay for the merging cost $length(A_1) + length(A_2) \leq 3*length(A_1)$. And the total insert operation cost is  \$$3* length(A_1) + 1$. The element $i$ in the $A_1$ or $A_2$ have a new $C_i - 1$ which is less than $C_i$. As a result, when we insert an element, we need to spend \$1 for new this single array, and add extract \$$3(\log_2 n)$ credit for it. So, the \textit{insert} operation run in only $O(\log n)$ amortized time.
\\

\textbf{For the \textit{remove-min} operation}, in $O(\log n)$ time to find the root \textit{x} with the minimum value. After we delete this element, we use the surplus credit for this element to pay for the merging cost.
We didn't need to do anything because the saving for the element $i$ which when wants to delete has credit \$$3C_i$ which is enough for remove. This entire process took only $O(\log n)$ time.
\\

To implement the remaining priority queue operations $decrease$-$key$, $increase$-$key$, and \textit{delete} operation. For all of them, we need spent $(O(\log n))$ time to find them firstly. \textbf{For the \textit{decrease-key(A, x, k)}}, since the length for any array is $O(log n)$, this takes a most  $O(log n)$ because we use this element new value $k$ to compare with its parent and, if it's smaller, it is swapped upwards. \textbf{For the \textit{increase-key(A, x, k)}}, this process is similar with the \textit{decrease-key(A, x, k)}. We use this element new value $k$ to compare with its children and, if it's bigger, it is swapped downwards. As a result, both \textit{decrease-key} and \textit{increase-key} run in only $O(\log n)$ amortized time. \textbf{For the \textit{delete} operation}, we can do the lazy deletion in the algorithm. When an element is deleted, we just need to mark it as $deleted$ but we didn't really delete it at that time. We clean it when it moves to the front of an arrays and when some one call the \textit{remove-min} function. So, we need to add $O(\log n)$ credit to that element when we marked $deleted$ flag on that element. We spend this cost for the $remove\-min$ operation. \\

So, the entire process for \textit{insert}, \textit{remove-min}, \textit{decrease-key}, \textit{increase-key} and \textit{delete} took only $O(\log n)$ amortized time.

\end{homeworkProblem}

\pagebreak
\textbf{References}

\begin{enumerate}
    \item http://moais.imag.fr/membres/marc.tchiboukdjian/mosig/amortized.pdf
    \item http://home.cse.ust.hk/~golin/COMP572/Notes/Heaps.pdf
\end{enumerate}


\end{document}
